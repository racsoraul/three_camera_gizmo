{"version":3,"sources":["utils.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["COMMANDS","Axes","debounce","inDebounce","ms","arguments","length","undefined","fn","_len","params","Array","_key","window","clearTimeout","setTimeout","apply","createCube","color","width","height","depth","geometry","BoxGeometry","material","MeshBasicMaterial","mesh","Mesh","edgesGeometry","EdgesGeometry","edgesMaterial","LineBasicMaterial","linewidth","edgesMesh","LineSegments","add","rotateCamera","sceneCamera","sceneCameraDistance","focusPoint","angle","axis","Y","position","y","z","X","Math","cos","sin","x","Z","Error","lookAt","gizmoAction","command","CHANGE_VIEW_TO_TOP","PI","CHANGE_VIEW_TO_BOTTOM","CHANGE_VIEW_TO_RIGHT","CHANGE_VIEW_TO_LEFT","CHANGE_VIEW_TO_FRONT","CHANGE_VIEW_TO_BACK","setupCameraGizmo","sceneContainer","sceneCameraFocusPoint","gizmoCameraDistance","raycaster","Raycaster","mouse","coordinates","Vector2","isDown","parentNode","gizmoRenderer","WebGLRenderer","alpha","antialias","devicePixelRatio","sceneRect","getBoundingClientRect","gizmoContainer","document","createElement","id","style","margin","top","concat","left","appendChild","gizmoRect","mouseMovement","event","clientX","clientY","onMouseMove","mouseDown","onMouseDown","mouseUp","onMouseUp","touchMove","touches","onTouchMove","touchStart","onTouchStart","touchEnd","onTouchEnd","addEventListener","aspect","setSize","domElement","gizmoScene","Scene","scene","rightRedCube","userData","leftRedCube","frontBlueCube","backBlueCube","topGreenCube","bottomGreenCube","addGizmoHandler","gizmoCamera","PerspectiveCamera","up","renderCameraGizmo","animateGizmo","destroyCameraGizmo","remove","setFromCamera","intersects","intersectObjects","children","object","copy","setLength","render","App","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","containerRef","React","createRef","renderer","camera","controls","frameId","gizmoManager","animate","requestAnimationFrame","onWindowsResize","current","containerWidth","clientWidth","containerHeight","clientHeight","updateProjectionMatrix","THREE","react_default","a","className","ref","CAMERA_FOCUS_POINT","Vector3","setClearColor","set","OrbitControls","enableKeys","cube","axes","removeEventListener","cancelAnimationFrame","Component","Boolean","location","hostname","match","ReactDOM","src_App_0","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"kLAyCYA,EASAC,sHATAD,oUASAC,sDAgBL,IAAMC,EAGiB,WAAkB,IAC1CC,EADyBC,EAAiBC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAZ,IAAKG,EAAOH,UAAAC,OAAA,EAAAD,UAAA,QAAAE,EAE9C,OAAO,WAAoB,QAAAE,EAAAJ,UAAAC,OAAhBI,EAAgB,IAAAC,MAAAF,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAhBF,EAAgBE,GAAAP,UAAAO,GACzBC,OAAOC,aAAaX,GACpBA,EAAaU,OAAOE,WAAW,kBAAMP,EAAGQ,MAAM,KAAMN,IAASN,KAW1D,SAASa,IAKR,IAJNC,EAIMb,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAJU,SAChBc,EAGMd,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAHU,EAChBe,EAEMf,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAFW,EACjBgB,EACMhB,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GADU,EAGViB,EAAW,IAAIC,cAAYJ,EAAOC,EAAQC,GAC1CG,EAAW,IAAIC,oBAAkB,CAAEP,UACnCQ,EAAO,IAAIC,OAAKL,EAAUE,GAG1BI,EAAgB,IAAIC,gBAAcH,EAAKJ,UACvCQ,EAAgB,IAAIC,oBAAkB,CAC1Cb,MAAO,SACPc,UAAW,MAEPC,EAAY,IAAIC,eAAaN,EAAeE,GAElD,OAAOJ,EAAKS,IAAIF,GAWlB,SAASG,EACPC,EACAC,EACAC,EACAC,GAEA,IADAC,EACApC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GADaJ,EAAKyC,EAElBL,EAAYM,SAASC,EAAI,EACzB,IAAIC,EAAIP,EAIR,OAAQG,GACN,KAAKxC,EAAK6C,EACRT,EAAYM,SAASC,EALnB,EAK2BG,KAAKC,IAAIR,GAASK,EAAIE,KAAKE,IAAIT,GAC5DH,EAAYM,SAASE,EAAIA,EAAIE,KAAKC,IAAIR,GANpC,EAMiDO,KAAKE,IAAIT,GAC5D,MACF,KAAKvC,EAAKyC,EACRL,EAAYM,SAASO,EARnB,EAQ2BH,KAAKC,IAAIR,GAASK,EAAIE,KAAKE,IAAIT,GAC5DH,EAAYM,SAASE,EAAIA,EAAIE,KAAKC,IAAIR,GATpC,EASiDO,KAAKE,IAAIT,GAC5D,MACF,KAAKvC,EAAKkD,EACR,MAAMC,MACJ,kFAINf,EAAYgB,OAAOd,GA+CrB,IAAMe,EAKMpD,EACV,GACA,SACEmC,EACAC,EACAC,EACAgB,GAEA,OAAQA,GACN,KAAKvD,EAASwD,mBACZpB,EAAaC,EAAaC,EAAqBC,EAAY,GAC3DH,EACEC,EACAC,EACAC,EACAQ,KAAKU,GAAK,EACVxD,EAAK6C,GAEP,MACF,KAAK9C,EAAS0D,sBACZtB,EAAaC,EAAaC,EAAqBC,EAAY,GAC3DH,EACEC,EACAC,EACAC,GACCQ,KAAKU,GAAK,EACXxD,EAAK6C,GAEP,MACF,KAAK9C,EAAS2D,qBACZvB,EAAaC,EAAaC,EAAqBC,EAAYQ,KAAKU,GAAK,GACrE,MACF,KAAKzD,EAAS4D,oBACZxB,EACEC,EACAC,EACAC,GACCQ,KAAKU,GAAK,GAEb,MACF,KAAKzD,EAAS6D,qBACZzB,EAAaC,EAAaC,EAAqBC,EAAY,GAC3D,MACF,KAAKvC,EAAS8D,oBACZ1B,EAAaC,EAAaC,EAAqBC,EAAYQ,KAAKU,OAwFjE,SAASM,EACdC,EACA3B,EACAC,EACA2B,GAEe,IADfC,EACe7D,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GADe,EAExB8D,EAAY,IAAIC,YAChBC,EAAQ,CACZC,YAAa,IAAIC,WAAS,GAAI,GAC9BC,QAAQ,GAGJC,EAAaT,EAAeS,WAElC,GAAIA,EAAY,CACd,IAAMC,EAAgB,IAAIC,gBAAc,CACtCC,OAAO,EACPC,WAAW,EACXC,iBAAkBjE,OAAOiE,mBAGrBC,EAAYf,EAAegB,wBAE3BC,EAAiBC,SAASC,cAAc,OAC9CF,EAAeG,GAAK,QACpBH,EAAeI,MAAM1C,SAAW,WAChCsC,EAAeI,MAAMlE,MAAQ,MAC7B8D,EAAeI,MAAMjE,OAAS,MAC9B6D,EAAeI,MAAMC,OAAS,MAC9BL,EAAeI,MAAME,IAArB,GAAAC,OAA8BT,EAAUQ,IAAxC,MACAN,EAAeI,MAAMI,KAArB,GAAAD,OAA+BT,EAAUU,KAAzC,MAEAhB,EAAWiB,YAAYT,GAEvB,IAAMU,EAAYV,EAAeD,wBAE3BY,EAhHV,SAAqBvB,EAAesB,GAClC,OAAO,SAAuBE,GAK5BxB,EAAMC,YAAYpB,GACd2C,EAAMC,QAAUH,EAAUF,MAAQE,EAAUxE,MAAS,EAAI,EAC7DkD,EAAMC,YAAY1B,IACbiD,EAAME,QAAUJ,EAAUJ,KAAOI,EAAUvE,OAAU,EAAI,GAuGxC4E,CAAY3B,EAAOsB,GACnCM,EA5DV,SAAqB5B,GACnB,OAAO,WACLA,EAAMG,QAAS,GA0DG0B,CAAY7B,GACxB8B,EAvDV,SAAmB9B,GACjB,OAAO,WACLA,EAAMG,QAAS,GAqDC4B,CAAU/B,GACpBgC,EA/FV,SAAqBhC,EAAesB,GAClC,OAAO,SAAuBE,GAK5BxB,EAAMC,YAAYpB,GACd2C,EAAMS,QAAQ,GAAGR,QAAUH,EAAUF,MAAQE,EAAUxE,MAAS,EAAI,EACxEkD,EAAMC,YAAY1B,IACbiD,EAAMS,QAAQ,GAAGP,QAAUJ,EAAUJ,KAAOI,EAAUvE,OAAU,EAAI,GAsFvDmF,CAAYlC,EAAOsB,GAC/Ba,EAnFV,SAAsBnC,EAAesB,GACnC,OAAO,SAAoBE,GAIzBxB,EAAMC,YAAYpB,GACd2C,EAAMS,QAAQ,GAAGR,QAAUH,EAAUF,MAAQE,EAAUxE,MAAS,EAAI,EACxEkD,EAAMC,YAAY1B,IACbiD,EAAMS,QAAQ,GAAGP,QAAUJ,EAAUJ,KAAOI,EAAUvE,OAAU,EAAI,EAEzEiD,EAAMG,QAAS,GAyEIiC,CAAapC,EAAOsB,GACjCe,EAtEV,SAAoBrC,GAClB,OAAO,WACLA,EAAMG,QAAS,GAoEEmC,CAAWtC,GAC5BY,EAAe2B,iBAAiB,YAAahB,GAC7CX,EAAe2B,iBAAiB,YAAaX,GAC7ChB,EAAe2B,iBAAiB,UAAWT,GAC3ClB,EAAe2B,iBAAiB,YAAaP,GAC7CpB,EAAe2B,iBAAiB,aAAcJ,GAC9CvB,EAAe2B,iBAAiB,WAAYF,GAE5C,IAAMG,EAASlB,EAAUxE,MAAQwE,EAAUvE,OAC3CsD,EAAcoC,QAAQnB,EAAUxE,MAAOwE,EAAUvE,QACjD6D,EAAeS,YAAYhB,EAAcqC,YAEzC,IAAMC,EAAa,IAAIC,SAvO3B,SAAyBC,GACvB,IAAMC,EAAelG,EAAW,UAChCkG,EAAaxE,SAASO,GAAK,EAC3BiE,EAAaC,SAAW,CAAE7D,QAASvD,EAAS2D,sBAE5C,IAAM0D,EAAcpG,EAAW,SAC/BoG,EAAY1E,SAASO,GAAK,EAC1BmE,EAAYD,SAAW,CAAE7D,QAASvD,EAAS4D,qBAE3C,IAAM0D,EAAgBrG,EAAW,KACjCqG,EAAc3E,SAASE,GAAK,EAC5ByE,EAAcF,SAAW,CAAE7D,QAASvD,EAAS6D,sBAE7C,IAAM0D,EAAetG,EAAW,SAChCsG,EAAa5E,SAASE,GAAK,EAC3B0E,EAAaH,SAAW,CAAE7D,QAASvD,EAAS8D,qBAE5C,IAAM0D,EAAevG,EAAW,OAChCuG,EAAa7E,SAASC,GAAK,EAC3B4E,EAAaJ,SAAW,CAAE7D,QAASvD,EAASwD,oBAE5C,IAAMiE,EAAkBxG,EAAW,UACnCwG,EAAgB9E,SAASC,GAAK,EAC9B6E,EAAgBL,SAAW,CAAE7D,QAASvD,EAAS0D,uBAE/CwD,EAAM/E,IAAIgF,GACVD,EAAM/E,IAAIkF,GACVH,EAAM/E,IAAImF,GACVJ,EAAM/E,IAAIoF,GACVL,EAAM/E,IAAIqF,GACVN,EAAM/E,IAAIsF,GA0MRC,CAAgBV,GAEhB,IAAMW,EAAc,IAAIC,oBAAkB,GAAIf,EAAQ,EAAG,KAIzD,OAHAc,EAAYE,GAAKxF,EAAYwF,GAGtB,CACLC,kBAAmBC,EACjB5D,EACAE,EACAK,EACAsC,EACAW,EACAzD,EACA7B,EACAC,EACA2B,GAEF+D,mBAAoB,kBAAM/C,EAAegD,WAG3C,MAAM7E,MAAM,4DAiBhB,SAAS2E,EACP5D,EACAE,EACAK,EACAsC,EACAW,EACAzD,EACA7B,EACAC,EACAC,GAEA,OAAO,WACL4B,EAAU+D,cAAc7D,EAAMC,YAAaqD,GAC3C,IAAMQ,EAAahE,EAAUiE,iBAAiBpB,EAAWqB,UAE5B,qBAAlBF,EAAW,IAAsB9D,EAAMG,QAChDlB,EACEjB,EACAC,EACAC,EACA4F,EAAW,GAAGG,OAAOlB,SAAS7D,SAIlCoE,EAAYhF,SAAS4F,KAAKlG,EAAYM,UACtCgF,EAAYhF,SAAS6F,UAAUtE,GAE/ByD,EAAYtE,OAAOd,GACnBmC,EAAc+D,OAAOzB,EAAYW,QCpVtBe,cA1Fb,SAAAA,EAAYC,GAAW,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAL,IACrBE,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAH,GAAAQ,KAAAH,KAAMJ,KATAQ,aAAeC,IAAMC,YAQNT,EAPfU,cAOe,EAAAV,EANf1B,WAMe,EAAA0B,EALfW,YAKe,EAAAX,EAJfY,cAIe,EAAAZ,EAHfa,aAGe,EAAAb,EAFfc,kBAEe,EAAAd,EAqEfe,QAAU,WAChBf,EAAKa,QAAU5I,OAAO+I,sBAAsBhB,EAAKe,SACjDf,EAAKU,SAASb,OAAOG,EAAK1B,MAAO0B,EAAKW,QACtCX,EAAKc,aAAa5B,qBAxEGc,EA8EfiB,gBAAkB3J,EAAS,GAAI,WACrC,GAAI0I,EAAKO,aAAaW,QAAS,CAC7B,IAAMC,EAAiBnB,EAAKO,aAAaW,QAAQE,YAC3CC,EAAkBrB,EAAKO,aAAaW,QAAQI,aAElDtB,EAAKW,OAAO1C,OAASkD,EAAiBE,EACtCrB,EAAKW,OAAOY,yBACZvB,EAAKU,SAASxC,QAAQiD,EAAgBE,MAnFxCpJ,OAAO+F,iBAAiB,SAAUgC,EAAKiB,iBAAiB,GACxDjB,EAAKU,SAAW,IAAIc,gBAAoB,CACtCxF,OAAO,EACPC,WAAW,EACXC,iBAAkBjE,OAAOiE,mBAE3B8D,EAAK1B,MAAQ,IAAIkD,QACjBxB,EAAKa,QAAU,EATMb,wEAarB,OACEyB,EAAAC,EAAAnF,cAAA,OAAKoF,UAAU,OACbF,EAAAC,EAAAnF,cAAA,0BACekF,EAAAC,EAAAnF,cAAA,4BADf,yBAGAkF,EAAAC,EAAAnF,cAAA,OAAKC,GAAG,QAAQoF,IAAKzB,KAAKI,4DAM9B,GAAIJ,KAAKI,aAAaW,QAAS,CAC7B,IACMW,EAAqB,IAAIC,UAAQ,EAAG,EAAG,GAEvCX,EAAiBhB,KAAKI,aAAaW,QAAQE,YAC3CC,EAAkBlB,KAAKI,aAAaW,QAAQI,aAC5CrD,EAASkD,EAAiBE,EAEhClB,KAAKO,SAASxC,QAAQiD,EAAgBE,GACtClB,KAAKO,SAASqB,cAAc,SAE5B5B,KAAKI,aAAaW,QAAQpE,YAAYqD,KAAKO,SAASvC,YAEpDgC,KAAKQ,OAAS,IAAIa,oBAAwB,GAAIvD,EAAQ,EAAG,KACzDkC,KAAKQ,OAAO5G,SAASiI,IAAI,EAAG,EAbJ,GAcxB7B,KAAKQ,OAAOlG,OAAOoH,GAEnB1B,KAAKS,SAAW,IAAIqB,IAAc9B,KAAKQ,OAAQR,KAAKI,aAAaW,SACjEf,KAAKS,SAASsB,YAAa,EAE3B,IAAMC,EAAO9J,EAAW,GAClB+J,EAAO,IAAIZ,aAAiB,GAClCrB,KAAK7B,MAAM/E,IAAI4I,GACfhC,KAAK7B,MAAM/E,IAAI6I,GAEfjC,KAAKW,aAAe3F,EAClBgF,KAAKI,aAAaW,QAClBf,KAAKQ,OA1BiB,EA4BtBkB,GAGF1B,KAAKY,0DAKP9I,OAAOoK,oBAAoB,SAAUlC,KAAKc,iBAAiB,GAC3DhJ,OAAOqK,qBAAqBnC,KAAKU,SACjCV,KAAKW,aAAa1B,4BAxEJmD,aCKEC,QACW,cAA7BvK,OAAOwK,SAASC,UAEe,UAA7BzK,OAAOwK,SAASC,UAEhBzK,OAAOwK,SAASC,SAASC,MACvB,2DCZNC,IAAS/C,OAAO4B,EAAAC,EAAAnF,cAACsG,EAAD,MAASvG,SAASwG,eAAe,SDmI3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.c340a523.chunk.js","sourcesContent":["import {\n  Vector3,\n  Mesh,\n  MeshBasicMaterial,\n  BoxGeometry,\n  PerspectiveCamera,\n  EdgesGeometry,\n  LineBasicMaterial,\n  LineSegments,\n  Scene,\n  WebGLRenderer,\n  Vector2,\n  Raycaster\n} from \"three\";\n\n/**\n * Generic function type.\n */\ntype GenericFunction<R = any> = (...args: any) => R;\n\ntype RenderCameraGizmo = () => void;\ntype DestoyCameraGizmo = () => void;\n\n/**\n * State of the mouse.\n */\ninterface IMouse {\n  coordinates: Vector2;\n  isDown: boolean;\n}\n\n/**\n * Utilities to handle the lifecycle of the camera gizmo.\n */\nexport interface IGizmoManager {\n  /** Re-renders the gizmo scene on every frame. */\n  renderCameraGizmo: RenderCameraGizmo;\n  /** Removes the DOM node of the gizmo and removes mouse listeners with it. */\n  destroyCameraGizmo: DestoyCameraGizmo;\n}\n\nexport enum COMMANDS {\n  CHANGE_VIEW_TO_TOP,\n  CHANGE_VIEW_TO_BOTTOM,\n  CHANGE_VIEW_TO_LEFT,\n  CHANGE_VIEW_TO_RIGHT,\n  CHANGE_VIEW_TO_FRONT,\n  CHANGE_VIEW_TO_BACK\n}\n\nexport enum Axes {\n  X,\n  Y,\n  Z\n}\n\n/**\n * Returns a function that will be invoked until the timeout is over.\n * This timeout restarts evertime the function gets invoked before\n * the interval stablished.\n *\n * @template R type of return of the function to debounce. Default `any`.\n * @param ms interval of time to wait for next invocation of the function.\n * By default value is `500`.\n * @param fn function, accepting any number of arguments, to debounce.\n */\nexport const debounce: <R>(\n  ms: number,\n  fn: GenericFunction<R>\n) => (...args: any) => void = (ms = 500, fn) => {\n  let inDebounce: number;\n  return (...params: any) => {\n    window.clearTimeout(inDebounce);\n    inDebounce = window.setTimeout(() => fn.apply(null, params), ms);\n  };\n};\n\n/**\n * Returns a cube of the specified color and dimensions.\n * @param color hex number.\n * @param width width of the cube. Default `1`.\n * @param height height of the cube. Default `1`.\n * @param depth depth of the cube. Default `1`.\n */\nexport function createCube(\n  color: number = 0xffffff,\n  width: number = 1,\n  height: number = 1,\n  depth: number = 1\n): Mesh {\n  //TODO: change to BufferGeometry\n  const geometry = new BoxGeometry(width, height, depth);\n  const material = new MeshBasicMaterial({ color });\n  const mesh = new Mesh(geometry, material);\n\n  // Add wireframe\n  const edgesGeometry = new EdgesGeometry(mesh.geometry);\n  const edgesMaterial = new LineBasicMaterial({\n    color: 0xababab,\n    linewidth: 2.5\n  });\n  const edgesMesh = new LineSegments(edgesGeometry, edgesMaterial);\n\n  return mesh.add(edgesMesh);\n}\n\n/**\n * Rotates the camera around the given `axis` the amount\n * of degrees specified.\n * @param sceneCamera camera to rotate around.\n * @param sceneCameraDistance distance from the focus point of scene.\n * @param angle degrees to rotate.\n * @param axis axis to rotate around. Default `Axes.Y`.\n */\nfunction rotateCamera(\n  sceneCamera: PerspectiveCamera,\n  sceneCameraDistance: number,\n  focusPoint: Vector3,\n  angle: number,\n  axis: Axes = Axes.Y\n) {\n  sceneCamera.position.y = 0;\n  let z = sceneCameraDistance,\n    y = 0,\n    x = 0;\n\n  switch (axis) {\n    case Axes.X:\n      sceneCamera.position.y = y * Math.cos(angle) + z * Math.sin(angle);\n      sceneCamera.position.z = z * Math.cos(angle) - y * Math.sin(angle);\n      break;\n    case Axes.Y:\n      sceneCamera.position.x = x * Math.cos(angle) + z * Math.sin(angle);\n      sceneCamera.position.z = z * Math.cos(angle) - x * Math.sin(angle);\n      break;\n    case Axes.Z:\n      throw Error(\n        \"Unsupported rotation. Currently there's no reason to rotate around the Z axis.\"\n      );\n  }\n\n  sceneCamera.lookAt(focusPoint);\n}\n\n/**\n * Adds gizmo handlers to the specified scene.\n * @param scene scene to add the camera gizmo.\n */\nfunction addGizmoHandler(scene: Scene) {\n  const rightRedCube = createCube(0x9c4c4c);\n  rightRedCube.position.x += 1;\n  rightRedCube.userData = { command: COMMANDS.CHANGE_VIEW_TO_RIGHT };\n\n  const leftRedCube = createCube(0x926d6d);\n  leftRedCube.position.x -= 1;\n  leftRedCube.userData = { command: COMMANDS.CHANGE_VIEW_TO_LEFT };\n\n  const frontBlueCube = createCube(0x0000ff);\n  frontBlueCube.position.z += 1;\n  frontBlueCube.userData = { command: COMMANDS.CHANGE_VIEW_TO_FRONT };\n\n  const backBlueCube = createCube(0x4c74c5);\n  backBlueCube.position.z -= 1;\n  backBlueCube.userData = { command: COMMANDS.CHANGE_VIEW_TO_BACK };\n\n  const topGreenCube = createCube(0x00ff00);\n  topGreenCube.position.y += 1;\n  topGreenCube.userData = { command: COMMANDS.CHANGE_VIEW_TO_TOP };\n\n  const bottomGreenCube = createCube(0xc6f5c6);\n  bottomGreenCube.position.y -= 1;\n  bottomGreenCube.userData = { command: COMMANDS.CHANGE_VIEW_TO_BOTTOM };\n\n  scene.add(rightRedCube);\n  scene.add(leftRedCube);\n  scene.add(frontBlueCube);\n  scene.add(backBlueCube);\n  scene.add(topGreenCube);\n  scene.add(bottomGreenCube);\n}\n\n/**\n * Triggers actions according to the command.\n * @param sceneCamera camera to react to actions.\n * @param sceneCameraDistance distance from the focus point of scene.\n * @param focusPoint focus point of the gizmo camera.\n * @param command action to execute.\n */\nconst gizmoAction: (\n  sceneCamera: PerspectiveCamera,\n  sceneCameraDistance: number,\n  focusPoint: Vector3,\n  command: COMMANDS\n) => void = debounce(\n  75,\n  (\n    sceneCamera: PerspectiveCamera,\n    sceneCameraDistance: number,\n    focusPoint: Vector3,\n    command: COMMANDS\n  ) => {\n    switch (command) {\n      case COMMANDS.CHANGE_VIEW_TO_TOP:\n        rotateCamera(sceneCamera, sceneCameraDistance, focusPoint, 0);\n        rotateCamera(\n          sceneCamera,\n          sceneCameraDistance,\n          focusPoint,\n          Math.PI / 2,\n          Axes.X\n        );\n        break;\n      case COMMANDS.CHANGE_VIEW_TO_BOTTOM:\n        rotateCamera(sceneCamera, sceneCameraDistance, focusPoint, 0);\n        rotateCamera(\n          sceneCamera,\n          sceneCameraDistance,\n          focusPoint,\n          -Math.PI / 2,\n          Axes.X\n        );\n        break;\n      case COMMANDS.CHANGE_VIEW_TO_RIGHT:\n        rotateCamera(sceneCamera, sceneCameraDistance, focusPoint, Math.PI / 2);\n        break;\n      case COMMANDS.CHANGE_VIEW_TO_LEFT:\n        rotateCamera(\n          sceneCamera,\n          sceneCameraDistance,\n          focusPoint,\n          -Math.PI / 2\n        );\n        break;\n      case COMMANDS.CHANGE_VIEW_TO_FRONT:\n        rotateCamera(sceneCamera, sceneCameraDistance, focusPoint, 0);\n        break;\n      case COMMANDS.CHANGE_VIEW_TO_BACK:\n        rotateCamera(sceneCamera, sceneCameraDistance, focusPoint, Math.PI);\n        break;\n    }\n  }\n);\n\n/**\n * Listener to keep track of the mouse position in the gizmo scene. It\n * converts the mouse coordinates to a normalized device coordinates\n * (-1 to +1).\n * @param mouseCoordinates mouse coordinates relative to the gizmo scene.\n * @param gizmoRect gizmo DOM node dimensions.\n */\nfunction onMouseMove(mouse: IMouse, gizmoRect: ClientRect) {\n  return function mouseMovement(event: MouseEvent) {\n    /**\n     * Calculate mouse position in normalized device coordinates\n     * (-1 to +1) for both components.\n     */\n    mouse.coordinates.x =\n      ((event.clientX - gizmoRect.left) / gizmoRect.width) * 2 - 1;\n    mouse.coordinates.y =\n      -((event.clientY - gizmoRect.top) / gizmoRect.height) * 2 + 1;\n  };\n}\n\n/**\n * Listener to keep track of the finger position in the gizmo scene. It\n * converts the coordinates to a normalized device coordinates\n * (-1 to +1).\n * @param mouseCoordinates mouse coordinates relative to the gizmo scene.\n * @param gizmoRect gizmo DOM node dimensions.\n */\nfunction onTouchMove(mouse: IMouse, gizmoRect: ClientRect) {\n  return function mouseMovement(event: TouchEvent) {\n    /**\n     * Calculate mouse position in normalized device coordinates\n     * (-1 to +1) for both components.\n     */\n    mouse.coordinates.x =\n      ((event.touches[0].clientX - gizmoRect.left) / gizmoRect.width) * 2 - 1;\n    mouse.coordinates.y =\n      -((event.touches[0].clientY - gizmoRect.top) / gizmoRect.height) * 2 + 1;\n  };\n}\n\nfunction onTouchStart(mouse: IMouse, gizmoRect: ClientRect) {\n  return function touchStart(event: TouchEvent) {\n    /**\n     * Update coordinates \"before detecting\" the touch.\n     */\n    mouse.coordinates.x =\n      ((event.touches[0].clientX - gizmoRect.left) / gizmoRect.width) * 2 - 1;\n    mouse.coordinates.y =\n      -((event.touches[0].clientY - gizmoRect.top) / gizmoRect.height) * 2 + 1;\n\n    mouse.isDown = true;\n  };\n}\n\nfunction onTouchEnd(mouse: IMouse) {\n  return function touchEnd() {\n    mouse.isDown = false;\n  };\n}\n\nfunction onMouseDown(mouse: IMouse) {\n  return function mouseDown() {\n    mouse.isDown = true;\n  };\n}\n\nfunction onMouseUp(mouse: IMouse) {\n  return function mouseUp() {\n    mouse.isDown = false;\n  };\n}\n\n/**\n * Setups the camera gizmo for a given scene container. Returns two functions:\n *  - to re-render the gizmo on every frame.\n *  - to remove the event mouse event listeners attached to the gizmo DOM node.\n * @param sceneContainer DOM node where the scene will be mounted.\n * @param sceneCamera camera of scene to track.\n * @param sceneCameraDistance distance of camera from the focus point of scene.\n * @param sceneCameraFocusPoint focus point of the camera.\n * @param gizmoCameraDistance How close the gizmo will look like. Default `5`.\n */\nexport function setupCameraGizmo(\n  sceneContainer: HTMLDivElement,\n  sceneCamera: PerspectiveCamera,\n  sceneCameraDistance: number,\n  sceneCameraFocusPoint: Vector3,\n  gizmoCameraDistance: number = 5\n): IGizmoManager {\n  const raycaster = new Raycaster();\n  const mouse = {\n    coordinates: new Vector2(-1, -1),\n    isDown: false\n  };\n\n  const parentNode = sceneContainer.parentNode;\n\n  if (parentNode) {\n    const gizmoRenderer = new WebGLRenderer({\n      alpha: true,\n      antialias: true,\n      devicePixelRatio: window.devicePixelRatio\n    });\n\n    const sceneRect = sceneContainer.getBoundingClientRect();\n\n    const gizmoContainer = document.createElement(\"div\");\n    gizmoContainer.id = \"gizmo\";\n    gizmoContainer.style.position = \"absolute\";\n    gizmoContainer.style.width = \"20%\";\n    gizmoContainer.style.height = \"20%\";\n    gizmoContainer.style.margin = \"5px\";\n    gizmoContainer.style.top = `${sceneRect.top}px`;\n    gizmoContainer.style.left = `${sceneRect.left}px`;\n\n    parentNode.appendChild(gizmoContainer);\n\n    const gizmoRect = gizmoContainer.getBoundingClientRect();\n\n    const mouseMovement = onMouseMove(mouse, gizmoRect);\n    const mouseDown = onMouseDown(mouse);\n    const mouseUp = onMouseUp(mouse);\n    const touchMove = onTouchMove(mouse, gizmoRect);\n    const touchStart = onTouchStart(mouse, gizmoRect);\n    const touchEnd = onTouchEnd(mouse);\n    gizmoContainer.addEventListener(\"mousemove\", mouseMovement);\n    gizmoContainer.addEventListener(\"mousedown\", mouseDown);\n    gizmoContainer.addEventListener(\"mouseup\", mouseUp);\n    gizmoContainer.addEventListener(\"touchmove\", touchMove);\n    gizmoContainer.addEventListener(\"touchstart\", touchStart);\n    gizmoContainer.addEventListener(\"touchend\", touchEnd);\n\n    const aspect = gizmoRect.width / gizmoRect.height;\n    gizmoRenderer.setSize(gizmoRect.width, gizmoRect.height);\n    gizmoContainer.appendChild(gizmoRenderer.domElement);\n\n    const gizmoScene = new Scene();\n    addGizmoHandler(gizmoScene);\n\n    const gizmoCamera = new PerspectiveCamera(45, aspect, 1, 100);\n    gizmoCamera.up = sceneCamera.up;\n\n    //TODO: return function to trigger on window resizing to adjust gizmo positioning.\n    return {\n      renderCameraGizmo: animateGizmo(\n        raycaster,\n        mouse,\n        gizmoRenderer,\n        gizmoScene,\n        gizmoCamera,\n        gizmoCameraDistance,\n        sceneCamera,\n        sceneCameraDistance,\n        sceneCameraFocusPoint\n      ),\n      destroyCameraGizmo: () => gizmoContainer.remove()\n    };\n  } else {\n    throw Error(\"There isn't a valid parent node for the gizmo container.\");\n  }\n}\n\n/**\n * Updates the gizmo on each frame to follow the new position of the scene camera.\n * @param raycaster ray casted to the gizmo canvas.\n * @param mouse state of the mouse relative to the gizmo canvas.\n * @param gizmoRenderer WebGLRender for the gizmo.\n * @param gizmoScene scene to show the gizmo.\n * @param gizmoCamera gizmo camera.\n * @param gizmoCameraDistance how far the gizmo camera will be.\n * @param sceneCamera scene camera to track.\n * @param sceneCameraDistance distance from the focus point of scene.\n * @param focusPoint focus point of the gizmo camera.\n * @returns function that executes the re-rendering logic.\n */\nfunction animateGizmo(\n  raycaster: Raycaster,\n  mouse: IMouse,\n  gizmoRenderer: WebGLRenderer,\n  gizmoScene: Scene,\n  gizmoCamera: PerspectiveCamera,\n  gizmoCameraDistance: number,\n  sceneCamera: PerspectiveCamera,\n  sceneCameraDistance: number,\n  focusPoint: Vector3\n): RenderCameraGizmo {\n  return () => {\n    raycaster.setFromCamera(mouse.coordinates, gizmoCamera);\n    const intersects = raycaster.intersectObjects(gizmoScene.children);\n\n    if (typeof intersects[0] !== \"undefined\" && mouse.isDown) {\n      gizmoAction(\n        sceneCamera,\n        sceneCameraDistance,\n        focusPoint,\n        intersects[0].object.userData.command\n      );\n    }\n\n    gizmoCamera.position.copy(sceneCamera.position);\n    gizmoCamera.position.setLength(gizmoCameraDistance);\n\n    gizmoCamera.lookAt(focusPoint);\n    gizmoRenderer.render(gizmoScene, gizmoCamera);\n  };\n}\n","import React, { Component } from \"react\";\nimport \"./App.css\";\nimport * as THREE from \"three\";\nimport OrbitControls from \"three-orbitcontrols\";\nimport { debounce, createCube, setupCameraGizmo, IGizmoManager } from \"./utils\";\nimport { Vector3 } from \"three\";\n\nclass App extends Component<{}> {\n  private containerRef = React.createRef<HTMLDivElement>();\n  private renderer: THREE.WebGLRenderer;\n  private scene: THREE.Scene;\n  private camera!: THREE.PerspectiveCamera;\n  private controls!: THREE.OrbitControls;\n  private frameId: number;\n  private gizmoManager!: IGizmoManager;\n\n  constructor(props: {}) {\n    super(props);\n    window.addEventListener(\"resize\", this.onWindowsResize, false);\n    this.renderer = new THREE.WebGLRenderer({\n      alpha: true,\n      antialias: true,\n      devicePixelRatio: window.devicePixelRatio\n    });\n    this.scene = new THREE.Scene();\n    this.frameId = 0;\n  }\n\n  public render() {\n    return (\n      <div className=\"App\">\n        <h1>\n          Usage of the <span>camera gizmo</span> with a simple scene.\n        </h1>\n        <div id=\"scene\" ref={this.containerRef} />\n      </div>\n    );\n  }\n\n  public componentDidMount() {\n    if (this.containerRef.current) {\n      const CAMERA_DISTANCE = 6;\n      const CAMERA_FOCUS_POINT = new Vector3(0, 0, 0);\n\n      const containerWidth = this.containerRef.current.clientWidth;\n      const containerHeight = this.containerRef.current.clientHeight;\n      const aspect = containerWidth / containerHeight;\n\n      this.renderer.setSize(containerWidth, containerHeight);\n      this.renderer.setClearColor(0x101010);\n\n      this.containerRef.current.appendChild(this.renderer.domElement);\n\n      this.camera = new THREE.PerspectiveCamera(45, aspect, 1, 10000);\n      this.camera.position.set(0, 0, CAMERA_DISTANCE);\n      this.camera.lookAt(CAMERA_FOCUS_POINT);\n\n      this.controls = new OrbitControls(this.camera, this.containerRef.current);\n      this.controls.enableKeys = false;\n\n      const cube = createCube(0x000000);\n      const axes = new THREE.AxesHelper(2);\n      this.scene.add(cube);\n      this.scene.add(axes);\n\n      this.gizmoManager = setupCameraGizmo(\n        this.containerRef.current,\n        this.camera,\n        CAMERA_DISTANCE,\n        CAMERA_FOCUS_POINT\n      );\n\n      this.animate();\n    }\n  }\n\n  public componentWillUnmount() {\n    window.removeEventListener(\"resize\", this.onWindowsResize, false);\n    window.cancelAnimationFrame(this.frameId);\n    this.gizmoManager.destroyCameraGizmo();\n  }\n\n  /**\n   * Start rendering the scene.\n   */\n  private animate = () => {\n    this.frameId = window.requestAnimationFrame(this.animate);\n    this.renderer.render(this.scene, this.camera);\n    this.gizmoManager.renderCameraGizmo();\n  };\n\n  /**\n   * Adjust canvas size on windows resizing.\n   */\n  private onWindowsResize = debounce(50, () => {\n    if (this.containerRef.current) {\n      const containerWidth = this.containerRef.current.clientWidth;\n      const containerHeight = this.containerRef.current.clientHeight;\n\n      this.camera.aspect = containerWidth / containerHeight;\n      this.camera.updateProjectionMatrix();\n      this.renderer.setSize(containerWidth, containerHeight);\n    }\n  });\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}